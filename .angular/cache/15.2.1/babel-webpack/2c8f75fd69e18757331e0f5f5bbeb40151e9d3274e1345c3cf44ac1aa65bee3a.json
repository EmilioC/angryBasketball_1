{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class GifsService {\n  /*   En particular, el constructor primero intenta obtener\r\n    los datos del historial previamente almacenados en el\r\n    objeto localStorage del navegador mediante el método getItem.\r\n     Si hay datos almacenados en el localStorage, se convierten\r\n     de una cadena JSON a un objeto JavaScript mediante el\r\n     método JSON.parse() y se asignan a la propiedad _historial.\r\n     Si no hay datos almacenados en el localStorage,\r\n     se inicializa _historial como una matriz vacía []. */\n  constructor(http) {\n    this.http = http;\n    this.apikey = \"N8segJHx4XezJ8U2f0Ma13fPMQIDoIA6\";\n    this.servicioUrl = 'https://api.giphy.com/v1/gifs';\n    this._historial = [];\n    this.limit = 10;\n    //TODO; Cambiar any por su tipo \n    this.resultados = [];\n    this._historial = JSON.parse(localStorage.getItem('historial')) || [];\n    /* El símbolo ! después de la llamada a getItem es un operador\r\n     de afirmación no nulo (non-null assertion operator), que le\r\n     dice a TypeScript que el valor devuelto por getItem no será\r\n      null o undefined. Esto es necesario porque getItem devuelve\r\n       una cadena o null, y el método JSON.parse() espera una cadena como argumento.\r\n    \r\n    if(localStorage.getItem('historial')){\r\n          this._historial = JSON.parse( localStorage.getItem('historial')!)\r\n        } */\n  }\n\n  get historial() {\n    /*  La sintaxis [...this._historial] indica que se debe\r\n    crear un nuevo arreglo que contenga los mismos elementos que _historial,\r\n     es decir, una copia del arreglo original. Esto se hace para evitar que se\r\n      modifique el arreglo original al que se hace referencia desde otras\r\n       partes del código.*/\n    return [...this._historial];\n  }\n  /* Insertamos valores al historial\r\n  método buscarGifs() recibe una cadena de texto query como argumento, que tiene un\r\n  valor predeterminado vacío en caso de que no se proporcione ningún valor. */\n  buscarGifs(query = '') {\n    /*     el método trim() a query para eliminar los espacios\r\n        en blanco al inicio y al final de la cadena. Luego,\r\n        se convierte query a minúsculas mediante el método toLocaleLowerCase(). */\n    query = query.trim().toLocaleLowerCase();\n    /*     En este fragmento de código, se utiliza el método includes() para verificar\r\n        si la consulta query ya existe en el historial de búsquedas _historial.\r\n         Si la consulta no existe en el historial, se agrega al principio del historial\r\n         utilizando el método unshift(). Si la consulta ya existe en el historial, no se agrega nada. */\n    if (!this._historial.includes(query)) {\n      /*   Insertamos el nuevo string al principio con .unshift */\n      this._historial.unshift(query);\n      /* En este caso, el método splice() se utiliza para eliminar todos los elementos del arreglo _historial\r\n      a partir del índice 0, excepto los primeros 10 elementos. Esto significa que si _historial tiene más de 10 elementos,\r\n      se eliminarán todos los elementos después del décimo elemento y solo se conservarán los primeros 10 elementos */\n      this._historial = this._historial.splice(0, 10);\n      localStorage.setItem('historial', JSON.stringify(this._historial));\n    }\n    const params = new HttpParams().set('api_key', this.apikey).set('limit', this.limit.toString()).set('q', query);\n    /*     símbolo ` (acento grave) en lugar de comillas. Los template literals permiten\r\n        la interpolación de variables y expresiones dentro de una cadena de texto\r\n        utilizando la sintaxis ${} y se pueden utilizar para formatear cadenas de texto\r\n         más complejas de manera más fácil y legible. */\n    this.http.get(`${this.servicioUrl}/search`, {\n      params: params\n    }).subscribe(resp => {\n      console.log(resp.data);\n      this.resultados = resp.data;\n      //Grabamos los resultados en el localStorage\n      localStorage.setItem('resultados', JSON.stringify(this.resultados));\n    });\n    console.log(\"***DESDE GIFSSERVICE***\", this._historial);\n  }\n}\nGifsService.ɵfac = function GifsService_Factory(t) {\n  return new (t || GifsService)(i0.ɵɵinject(i1.HttpClient));\n};\nGifsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: GifsService,\n  factory: GifsService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AACA,SAAqBA,UAAU,QAAQ,sBAAsB;;;AAO7D,OAAM,MAAOC,WAAW;EASxB;;;;;;;;EAQEC,YAAoBC,IAAgB;IAAhB,SAAI,GAAJA,IAAI;IAfhB,WAAM,GAAW,kCAAkC;IACnD,gBAAW,GAAW,+BAA+B;IACrD,eAAU,GAAa,EAAE;IACzB,UAAK,GAAW,EAAE;IAC5B;IACS,eAAU,GAAU,EAAE;IAW3B,IAAI,CAACC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAAEC,YAAY,CAACC,OAAO,CAAC,WAAW,CAAE,CAAC,IAAI,EAAE;IAE3E;;;;;;;;;EAUG;;EAED,IAAIC,SAAS;IACX;;;;;IAKA,OAAO,CAAC,GAAG,IAAI,CAACL,UAAU,CAAC;EAC7B;EACA;;;EAGAM,UAAU,CAACC,QAAgB,EAAE;IAE3B;;;IAGAA,KAAK,GAAGA,KAAK,CAACC,IAAI,EAAE,CAACC,iBAAiB,EAAE;IACxC;;;;IAIA,IAAI,CAAC,IAAI,CAACT,UAAU,CAACU,QAAQ,CAACH,KAAK,CAAC,EAAE;MACpC;MACA,IAAI,CAACP,UAAU,CAACW,OAAO,CAACJ,KAAK,CAAC;MAC9B;;;MAGA,IAAI,CAACP,UAAU,GAAG,IAAI,CAACA,UAAU,CAACY,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC;MAE/CT,YAAY,CAACU,OAAO,CAAC,WAAW,EAAEZ,IAAI,CAACa,SAAS,CAAE,IAAI,CAACd,UAAU,CAAE,CAAC;;IAGtE,MAAMe,MAAM,GAAG,IAAInB,UAAU,EAAE,CAC9BoB,GAAG,CAAC,SAAS,EAAE,IAAI,CAACC,MAAM,CAAC,CAC3BD,GAAG,CAAC,OAAO,EAAE,IAAI,CAACE,KAAK,CAACC,QAAQ,EAAE,CAAC,CACnCH,GAAG,CAAC,GAAG,EAACT,KAAK,CAAC;IAGnB;;;;IAII,IAAI,CAACR,IAAI,CAACqB,GAAG,CAAqB,GAAI,IAAI,CAACC,WAAY,SAAS,EAAE;MAAEN,MAAM,EAAGA;IAAM,CAAE,CAAC,CACrFO,SAAS,CAAEC,IAAI,IAAI;MAClBC,OAAO,CAACC,GAAG,CAAEF,IAAI,CAACG,IAAI,CAAC;MACvB,IAAI,CAACC,UAAU,GAAGJ,IAAI,CAACG,IAAI;MAC3B;MACAvB,YAAY,CAACU,OAAO,CAAC,YAAY,EAAEZ,IAAI,CAACa,SAAS,CAAE,IAAI,CAACa,UAAU,CAAE,CAAC;IACvE,CAAC,CAAC;IAEFH,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAE,IAAI,CAACzB,UAAU,CAAC;EACzD;;AAnFWH,WAAW;mBAAXA,WAAW;AAAA;AAAXA,WAAW;SAAXA,WAAW;EAAA+B,SAAX/B,WAAW;EAAAgC,YAFV;AAAM","names":["HttpParams","GifsService","constructor","http","_historial","JSON","parse","localStorage","getItem","historial","buscarGifs","query","trim","toLocaleLowerCase","includes","unshift","splice","setItem","stringify","params","set","apikey","limit","toString","get","servicioUrl","subscribe","resp","console","log","data","resultados","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\cordo\\VisualCode\\appProject\\angular\\chatGPT_1-1\\src\\app\\gifs\\services\\gifs.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpParams } from '@angular/common/http';\r\nimport { SearchGifsResponse, Gif } from '../interfaces/gifs.interface';\r\n\r\n@Injectable({\r\n  /*   root indica que estará disponible a nivel global */\r\n  providedIn: 'root'\r\n})\r\nexport class GifsService {\r\n\r\n  private apikey: string = \"N8segJHx4XezJ8U2f0Ma13fPMQIDoIA6\";\r\n  private servicioUrl: string = 'https://api.giphy.com/v1/gifs';\r\n  private _historial: string[] = [];\r\n  private limit: number = 10;\r\n//TODO; Cambiar any por su tipo \r\n  public resultados: Gif[] = [];\r\n\r\n/*   En particular, el constructor primero intenta obtener \r\n  los datos del historial previamente almacenados en el \r\n  objeto localStorage del navegador mediante el método getItem.\r\n   Si hay datos almacenados en el localStorage, se convierten \r\n   de una cadena JSON a un objeto JavaScript mediante el \r\n   método JSON.parse() y se asignan a la propiedad _historial. \r\n   Si no hay datos almacenados en el localStorage, \r\n   se inicializa _historial como una matriz vacía []. */\r\n  constructor(private http: HttpClient) {\r\n    this._historial = JSON.parse( localStorage.getItem('historial')!) || []\r\n\r\n/* El símbolo ! después de la llamada a getItem es un operador\r\n de afirmación no nulo (non-null assertion operator), que le \r\n dice a TypeScript que el valor devuelto por getItem no será\r\n  null o undefined. Esto es necesario porque getItem devuelve\r\n   una cadena o null, y el método JSON.parse() espera una cadena como argumento. \r\n\r\nif(localStorage.getItem('historial')){\r\n      this._historial = JSON.parse( localStorage.getItem('historial')!)\r\n    } */\r\n    \r\n   }\r\n\r\n  get historial() {\r\n    /*  La sintaxis [...this._historial] indica que se debe \r\n    crear un nuevo arreglo que contenga los mismos elementos que _historial,\r\n     es decir, una copia del arreglo original. Esto se hace para evitar que se\r\n      modifique el arreglo original al que se hace referencia desde otras\r\n       partes del código.*/\r\n    return [...this._historial];\r\n  }\r\n  /* Insertamos valores al historial\r\n  método buscarGifs() recibe una cadena de texto query como argumento, que tiene un \r\n  valor predeterminado vacío en caso de que no se proporcione ningún valor. */\r\n  buscarGifs(query: string = '') {\r\n\r\n    /*     el método trim() a query para eliminar los espacios \r\n        en blanco al inicio y al final de la cadena. Luego, \r\n        se convierte query a minúsculas mediante el método toLocaleLowerCase(). */\r\n    query = query.trim().toLocaleLowerCase();\r\n    /*     En este fragmento de código, se utiliza el método includes() para verificar \r\n        si la consulta query ya existe en el historial de búsquedas _historial.\r\n         Si la consulta no existe en el historial, se agrega al principio del historial \r\n         utilizando el método unshift(). Si la consulta ya existe en el historial, no se agrega nada. */\r\n    if (!this._historial.includes(query)) {\r\n      /*   Insertamos el nuevo string al principio con .unshift */\r\n      this._historial.unshift(query);\r\n      /* En este caso, el método splice() se utiliza para eliminar todos los elementos del arreglo _historial \r\na partir del índice 0, excepto los primeros 10 elementos. Esto significa que si _historial tiene más de 10 elementos, \r\nse eliminarán todos los elementos después del décimo elemento y solo se conservarán los primeros 10 elementos */\r\n      this._historial = this._historial.splice(0, 10);\r\n\r\n      localStorage.setItem('historial', JSON.stringify( this._historial ));\r\n    }\r\n\r\n    const params = new HttpParams()\r\n    .set('api_key', this.apikey)\r\n    .set('limit', this.limit.toString())\r\n    .set('q',query)\r\n   \r\n\r\n/*     símbolo ` (acento grave) en lugar de comillas. Los template literals permiten \r\n    la interpolación de variables y expresiones dentro de una cadena de texto \r\n    utilizando la sintaxis ${} y se pueden utilizar para formatear cadenas de texto\r\n     más complejas de manera más fácil y legible. */\r\n    this.http.get<SearchGifsResponse>(`${ this.servicioUrl }/search`, { params : params })\r\n    .subscribe( resp  =>{\r\n      console.log( resp.data);\r\n      this.resultados = resp.data;\r\n      //Grabamos los resultados en el localStorage\r\n      localStorage.setItem('resultados', JSON.stringify( this.resultados ));\r\n    })\r\n\r\n    console.log(\"***DESDE GIFSSERVICE***\", this._historial);\r\n  }\r\n}\r\n/*     método de JavaScript que se utiliza para realizar solicitudes \r\n    HTTP a servidores web y obtener recursos de la red. \r\n    fetch('https://api.giphy.com/v1/gifs/search?api_key=N8segJHx4XezJ8U2f0Ma13fPMQIDoIA6&q=developer&limit=10')\r\n    .then( resp => {\r\n      resp.json().then(data => {\r\n        console.log(data)\r\n      })\r\n    }) \r\n    \r\n    \r\n    // llamada con url\r\n     this.http.get<SearchGifsResponse>(`https://api.giphy.com/v1/gifs/search?api_key=N8segJHx4XezJ8U2f0Ma13fPMQIDoIA6&q=${ query }&limit=10`)\r\n    .subscribe( resp  =>{\r\n      console.log( resp.data);\r\n      this.resultados = resp.data;\r\n      //Grabamos los resultados en el localStorage\r\n      localStorage.setItem('resultados', JSON.stringify( this.resultados ));\r\n    })*/"]},"metadata":{},"sourceType":"module","externalDependencies":[]}